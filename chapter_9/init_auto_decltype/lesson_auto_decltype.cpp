/*
    Вычисляемый тип (auto и decltype)
    В языке С++, начиная со стандарта С++11, ключевое слово auto радикально изменило свое назначение.
    Если раньше в язык Си оно вводилось для явного обозначения автоматических переменных,
        то есть, тех, что располагаются в стековом фрейме, то теперь с его помощью можно объявлять переменные
        вычисляемого типа. 
    Автоматические (локальные) переменные - те, что располагаются в стековом фрейме FILO

    auto - переменные вычисляемого типа
    decltype - полный учет идентичности типа переменной (слова const, ссылки и тд)

*/
#include <iostream>

int main()
{
    auto i = -100;      // тип int
    auto d = 76.98;     // тип double
    auto g = 0.55f;     // тип float
    auto h = 'f';       // тип char
/*
    auto i = 1 + 2 - 10;      // тип int
    auto d = 1 + i + 3.0;     // тип double
    auto g = 55u;     // тип unsigned int
    auto h = (short)10 + 100000UL;       // тип unsigned long
*/

/* 
    Если перед типами прописать ключевое слово const:
    Компилятор старается найти наиболее общий тип при учете ссылок и модификаторов.
    Поэтому везде, где это допустимо, ключевое слово const отбрасывается при вычислении типа переменной
*/
    const int *ptr = nullptr;
    const int k{0};                  
    const int& lk = k;            // ссылка

    auto t1 = k;        // int
    auto t2 = *ptr;     // int  разыменование указателя
    auto t3 = ptr;      // const int *    указатель
    auto t4 = &ptr;     // const int **   указатель на указатель
    auto t5 = lk;       // int

/*
    Однако если для нас важно сохранить полную идентичность типа переменной, например,
    ссылку оставить ссылкой, или не отбрасывать модификатор const,
    то при объявлении переменных можно воспользоваться еще одним новым ключевым словом decltype
    следующим образом:
*/

    decltype(k) var1 = 1;   // const int
    decltype(ptr) var2;     // const int *
    decltype(lk) var3 = k;  // const int &

    return 0;
}