/*
    Методы shared_ptr:
        get() – получение «сырого» указателя на выделенную область памяти;
        reset() – меняет значение указателя на другую область памяти, либо на значение nullptr, если ничего не указано;
        swap() – меняет адреса двух указателей между собой;
        unique() – возвращает true (1), если на выделенную область ссылается только один указатель, и false (0) – в противном случае;
        use_count() – возвращает текущее значение счетчика conter для текущей области памяти.
*/

#include <iostream>
#include <memory>       // заголовок для умных указателей unique_ptr, shared_ptr

int main()
{
    std::shared_ptr<int> ptr_1 {std::make_shared<int>(3)};
    std::shared_ptr<int> ptr_2 {ptr_1};
     
    int* p = ptr_1.get();   // получаем классический (сырой) указатель из шаблонного класса shared_ptr (разные типы)

    /*
        1. выделили новую область памяти с помощью оператора new для массива в 5 элементов
        2. получили стандартный указатель на начало этого массива
        3. с его помощью прочитали и вывели значения в консоль
        * К сожалению, указатели типа shared_ptr могут работать с массивами, только начиная с версии языка C++20
            До этого придется использовать оператор new
    */

    ptr_2.reset(new int[5] {1, 2, 3});  // заменяем одну область памяти на другую
    int* ar = ptr_2.get();              // получаем сырой указатель
 
    for(int i = 0;i < 5;++i)
        std::cout << ar[i] << " ";
    std::cout << std::endl;

    ptr_2.swap(ptr_1);  // меняем адреса между собой
    std::cout << *ptr_2 << " " << ptr_1.use_count() << std::endl;   // счетчик указателей на область памяти ptr_1
    std::cout << ptr_1.unique() << std::endl;                       // проверка уникальности указателя


    return 0;
}