/*
    В практике программирования чаще используются указатели вида shared_ptr, которые также автоматически освобождают
    неиспользуемую память, но в отличие от unique_ptr могут ссылаться на нее во множественном числе

    Контроль памяти указателей типа shared_ptr:
        1. Указатель ptr инициализируется на некоторую область памяти
            std::shared_ptr<int> ptr_1 {std::make_shared<int>(3)};
        2. Формируется объект самого указателя ptr_1
        3. Формируется область памяти для хранения целочисленного значения типа int
        4. Специальный счетчик counter указателей на выделенную область памяти

    Счетчик увеличивается, если на область памяти указывает еще один shared_ptr
    Если счетчик = 0, то область памяти автоматически освобождается
    НЕЛЬЗЯ смешивать указатели типов shared_ptr с unique_ptr
*/

#include <iostream>
#include <memory>       // заголовок для умных указателей unique_ptr, shared_ptr

int main()
{
    // Все эти указатели будут принимать значение nullptr. Виды инициализации
    /*
        Создаем указатель шаблонного типа shared_ptr
        Выделяем область памяти в куче, типа int со значением 11
        В результате ptr будет ссылаться на область памяти для хранения целочисленного значения 11 типа int.
    */
    std::shared_ptr<int> ptr{std::make_shared<int>(11)};    
    std::shared_ptr<int> ptr_2 {};
    std::shared_ptr<int> ptr_3 {nullptr};
    // Отличительный способ инициализации для shared_ptr. ptr и ptr_4 ссылаются на одну и ту же область памяти
    std::shared_ptr<int> ptr_4 {ptr}; 

    // Пользоваться указателем ptr можно абсолютно так же, как и обычным указателем на тип int
    ptr_2 = ptr; // присвоение адреса указателя ptr указателю ptr_2
    *ptr = 10;  // запись числа 10 по адресу указателя ptr
    std::cout << ptr_2 << " " << *ptr_2 << std::endl;  // чтение и вывод в консоль значения по указателю ptr_2

    // Адресная арифметика с умными указателями запрещена
/*
    ptr_2 += 10;
    auto res = ptr_3 - ptr_4;
*/

    return 0;
}