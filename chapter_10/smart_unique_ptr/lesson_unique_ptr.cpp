/*
    Как я уже неоднократно отмечал, все базовые операторы и функции выделения/освобождения памяти, строго говоря, являются небезопасными:
    new, delete, malloc(), calloc(), realloc(), free()
    Наиболее часто, в практике программирования, можно столкнуться со следующими ситуациями:
        память была выделена, но не освобождена (утечка памяти);
        память была освобождена, но работа с ней продолжается так, словно она остается выделенной;
        память не была выделена, но в нее выполняется запись данных;
        попытка несколько раз освободить одну и ту же область памяти.

    К сожалению, даже при строгом контроле порядка вызовов операторов или функций выделения и освобождения памяти,
        вероятность возникновения приведенных ситуаций остается довольно высокой.
    Спрашивается, как минимизировать подобные ошибки, а еще лучше совсем их избежать?
    Для этого в языках высокого уровня, таких как Java, Python, C#, предусмотрен механизм «сборки мусора»,
        который отслеживает неиспользуемую память и автоматически ее освобождает.
    Но в языке C++ нет такого сборщика мусора, т.к. это низкоуровневый язык программирования и сами сборщики пишутся зачастую на нем.
    Однако некоторые решения все же есть. Это использование, так называемых, умных (smart) указателей.

    unique_ptr – «уникальный» (в единственном числе) smart-указатель, ссылающийся на выделенную область памяти (или принимающий значение nullptr);
    shared_ptr – smart-указатель, допускающий множественные адресации на одну и ту же выделенную область памяти.

    Инициализация в момент объявления - частая практика:
        std::unique_ptr<int> ptr {std::make_unique<int>()};
    Причем, до стандарта C++14 эта инициализация прописывалась так:
        std::unique_ptr<int> ptr_2 {new int {-6}};

    Умность указателей заключается в том, что они сами контролируют выделенную область памяти,
        и в нужный момент ее освобождают

    Smart-указатели типа unique_ptr имеют ряд полезных методов:
        get() – возвращает «сырой» указатель на выделенную область памяти;
        release() – возвращает указатель на выделенную область памяти и «отвязывает» smart-указатель от нее;
        reset() – меняет значение указателя на другую область памяти, либо на значение nullptr, если ничего не указано;
        swap() – выполняет обмен адресами smart-указателей между собой.

*/

#include <iostream>
#include <memory>   // smart-указатели

int main()
{
    // std::unique_ptr - шаблонный класс. Через <> указываем, с каким типом данных он работает

    std::unique_ptr<int> ptr;               // в любом случае будет инициализирован значением nullptr
    std::unique_ptr<int> ptr_2 {};
    std::unique_ptr<int> ptr_3 {nullptr};

    // инициализируем указатель числом 10
    if(!ptr)
        ptr = std::make_unique<int>(10);    // выделение памяти для умного указателя, вместо new (рекомендуется с С++14)
    
    ptr = std::make_unique<int>(11);    // не будет ошибки, дополнительно освобождать не требуется
    ptr = std::make_unique<int>(12);

    *ptr = 7;

    std::cout << *ptr << std::endl;

    return 0;
}