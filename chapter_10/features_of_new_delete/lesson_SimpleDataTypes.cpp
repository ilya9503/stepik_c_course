/*
    Динамическое выделение памяти в С++
    
    Стековая память (Stack) и куча (Heap) — это два разных вида памяти, используемых программами во время выполнения.

    Стек (Stack)
    Стек — это область памяти, которая управляется по принципу LIFO (Last In, First Out).
        В ней хранятся локальные переменные, параметры функций и адреса возврата при вызовах функций.
        Автоматическое управление памятью: выделение и освобождение памяти происходит при входе и выходе из функции.
        Размер стека ограничен (зависит от настроек ОС, обычно от 1 до 8 МБ).
        Данные из стека живут только в рамках области видимости функции.

    Куча (Heap)
    Куча — это область памяти, управляемая вручную или с помощью сборщика мусора, где хранятся объекты с неопределённым временем жизни.
    Характеристики кучи:
        Гибкое управление памятью: программист сам выделяет и освобождает память (например, в C++ с помощью new и delete).
        Доступ к данным занимает больше времени, чем в стеке, из-за накладных расходов на управление памятью.
        Размер кучи ограничен только доступной оперативной памятью.
        
    Когда использовать стек, а когда кучу?
        Стек — когда нужны временные переменные с ограниченной областью видимости.
        Куча — когда нужно выделить память для сложных структур, которые живут дольше, чем выполнение одной функции.

        В большинстве случаев лучше использовать стек, так как он работает быстрее и безопаснее. Куча нужна только тогда, когда стек недостаточен.
*/
#include <iostream>
 
using std::cout;
using std::endl;

int main(void)
{
    /*
        Создаем объекты примитивных типов данных
        Выделяем для них память в куче 
    */

    int* p1 = new int;                      // неопределенное значение (не инициализирован)
    double* p2 {new double()};              // инициализируется 0
    short* p3 {new short{-5}};              // инициализируется -5
    unsigned* p4 {new unsigned(11)};        // инициализируется 11

    /*
        Создаем массивы объектов примитивных типов данных
        Выделяем для них память в куче 
    */

    int* ar_1 {new int[7] {}};              // int* ar_1 = new new int[7] {};
    int* ar_2 {new int[4] ()};              // int* ar_2 = new new int[7] ();
    short* ar_3 {new short[11] { 1, 2 }};   // 1, 2, 0, 0
 

 
    cout << *p1 << " " << *p2 << " " << *p3 << " " << *p4 << endl;

    /*
        Нельзя дважды освобождать одну и ту же область памяти
        Перед этим обнуляем указатель
    */

    delete p1;
    p1 = nullptr;   // обнуляем указатель, для избежания ошибки повторного освобождения области памяти
    delete p1;

    delete p2;
    delete p3;
    delete p4;

    delete ar_1;
    delete ar_2;
    delete ar_3;
 
    return 0;
}