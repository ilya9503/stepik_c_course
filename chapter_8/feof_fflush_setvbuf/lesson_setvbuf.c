/*
    Функция fopen(), открывая файловый поток, автоматически формирует входной или выходной буфер.
    Но мы, при необходимости, можем определить свой собственный с помощью функции:
    Change stream buffering
    int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );
        buffer – это адрес области памяти для буфера (если равен NULL, то буфер создается автоматически);
        mode – режим работы буфера;
        size – размер буфера в байтах. Режимы определены следующими константами:
            _IOFBF – полная буферизация (очистка после заполнения буфера);
            _IOLBF – построчная буферизация (очистка по символу переноса строки);
            _IONBF – выключение буферизации.
    Функция setvbuf() должна вызываться после создания потока, но перед использованием какой-либо операции записи/чтения данных из этого потока.
*/
#include <stdio.h>
 
enum {buffer_size=512, data_size=100};  // р-р буфера и данных
 
int main(void)
{
    char buffer[buffer_size] = {0};
    char data[data_size];
 
    FILE* fp = fopen("data_rubusd2.csv", "r");  // открываем файл на чтение
    if(fp == NULL) {
        perror("data_rubusd2.csv");
        return 1;
    }
 
    if(setvbuf(fp, buffer, _IOFBF, buffer_size) != 0) { // создаем свой собственный буфер потока вместо дефолтного
        puts("Incorrect type or size of buffer");
        return 2;
    }
 
    fgets(data, sizeof(data), fp);      //  считаем 1-ую строчку из файла и поместим в data 
    puts(buffer);                       //  буфер выведет все содержимое файла, несмотря на то, что мы его туда не записывали вручную
    puts("----------------");
    puts(data);                         // выведет 1-ю строчку
 
    fclose(fp);
    return 0;
}